#!/usr/bin/env python

from collections import defaultdict
import argparse
import os
import sys
import base64



################################################################################
# Operands to instructions and directives
################################################################################
class Register(object):
  def __init__(self, reg):
    self.reg = reg

  def str(self, sym):
    return self.reg

class Immediate(object):
  def __init__(self, imm):
    self.imm = imm

  def str(self, sym):
    return self.imm

class Symbol(object):
  def __init__(self, label, imm):
    self.label = label
    self.imm = imm

  def str(self, sym):
    if self.imm < 0:
      return '%s-%d' % (sym(self.label), -self.imm)
    if self.imm > 0:
      return '%s+%d' % (sym(self.label), +self.imm)
    return sym(self.label)

class String(object):
  def __init__(self, value):
    self.value = value

  def str(self, sym):
    return self.value



################################################################################
# Instructions which are part of atoms
################################################################################
class Directive(object):
  def __init__(self, op, args):
    self.op = op
    self.args = args

  def str(self, sym):
    return '  %s %s' % (
        self.op.ljust(12),
        ', '.join(x.str(sym) for x in self.args)
    )

class Instruction(object):
  def __init__(self, op, args, annot):
    self.op = op
    self.args = args
    self.annot = annot

  def str(self, sym):
    return '  %s %s%s' % (
        self.op.ljust(16),
        ', '.join(x.str(sym) for x in self.args),
        '' if not self.annot else ' ' + ' '.join('@' + a for a in self.annot)
    )

class Label(object):
  def __init__(self, label):
    self.label = label
    self.is_weak = False
    self.is_global = False

  def str(self, sym):
    return sym(self.label) + ':'



################################################################################
# A module, corresponding to an object file.
################################################################################
class Module(object):
  def __init__(self):
    self.seg_text = []
    self.seg_data = []
    self.seg_const = []
    self.seg_bss = []

    self.weaks = set()
    self.globl = set()
    self.defs = set()
    self.needs = set()


################################################################################
# Parses an object into a stream of atoms.
################################################################################
def parse_object(data):
  """Parses a file, extracting instructions."""

  def insts():
    """Helper generator to parse the stream into instructions."""
    for line in data.split('\n'):
      # Find an empty line.
      if '"' not in line:
        line = line.split('#')[0].strip().replace('\t', ' ')
      else:
        line = line.strip()
      if not line: continue

      # Split off annotations.
      annots = line.split(' @')
      line = annots[0]
      annots = annots[1:]

      # Split off arguments.
      cmd = line.split(' ')[0].split('\t')[0]
      if cmd == '.ascii' or cmd == '.asciz':
        args = [line[len(cmd):]]
      else:
        args = [x for x in (t.strip() for t in line[len(cmd):].split(',')) if x]

      # Rewrite some commands.
      if cmd == '.section' and args[0] == '".note.GNU-stack"':
        continue
      if cmd == '.section' and args[0] == '__TEXT':
        cmd = '.text'
        args = []
      if cmd == '.section' and args[0].startswith('.rodata'):
        cmd = '.const'
        args = []

      def parse(arg):
        if arg.startswith('$') or arg.startswith('['):
          return Register(arg)
        if '"' in arg:
          return String(arg)
        if '+' in arg and not arg.startswith('+'):
          tokens = arg.split('+')
          return Symbol(tokens[0].split('@')[0], +int(tokens[1]))
        if '-' in arg and not arg.startswith('-'):
          tokens = arg.split('-')
          return Symbol(tokens[0].split('@')[0], -int(tokens[1]))
        if arg.startswith('0x') or arg.startswith('-') or arg.isdigit():
          return Immediate(arg)
        return Symbol(arg.split('@')[0], 0)

      if cmd not in ['.call', '.args']:
        args = [parse(arg) for arg in args]
      else:
        args = [Immediate(arg) for arg in args]

      if cmd.endswith(':'):
        # Label
        yield Label(cmd[:-1])
      elif not cmd.startswith('.'):
        # Instruction
        yield Instruction(cmd, args, annots)
      else:
        # Directive
        if cmd in ['.file', '.ident']:
          continue
        if cmd == '.comm':
          yield Directive('.data', [])
          yield Directive('.weak', [Symbol(args[0].label, 0)])
          yield Label(args[0].label)
          yield Directive('.align', [args[2]])
          yield Directive('.space', [args[1]])
        elif cmd == '.p2align':
          yield Directive('.align', [Immediate(str(2**int(args[0].imm)))])
        else:
          yield Directive(cmd, args)

  m = Module()

  seg = m.seg_text
  for i in insts():
    """Split the stream into segments."""
    if isinstance(i, Label):
      m.defs.add(i.label)
      seg.append(i)
      continue

    if isinstance(i, Directive):
      if i.op == '.text':  seg = m.seg_text;  continue
      if i.op == '.data':  seg = m.seg_data;  continue
      if i.op == '.bss':   seg = m.seg_bss;   continue
      if i.op == '.const': seg = m.seg_const; continue

      if i.op == '.weak':  m.weaks.add(i.args[0].label); continue
      if i.op == '.globl': m.globl.add(i.args[0].label); continue

    for arg in i.args:
      if isinstance(arg, Symbol):
        m.needs.add(arg.label)

    seg.append(i)

  m.globl |= m.weaks
  m.needs = m.needs - m.defs
  m.defs = m.defs & m.globl
  return m


def emit_object(seg, o, n, m, defs, globls):
  def emit_sym(sym):
    if sym in globls:
      return sym
    return '%s.%d' % (sym, n)

  def emit_segment(name, insts):
    if not insts or name != seg: return
    skip = False
    for inst in insts:
      if isinstance(inst, Label):
        skip = inst.label in m.weaks and inst.label in defs
      if not skip:
        o.write(inst.str(emit_sym))
        o.write('\n')

  emit_segment('text', m.seg_text)
  emit_segment('const', m.seg_const)
  emit_segment('bss', m.seg_bss)
  emit_segment('data', m.seg_data)
  o.flush()



def main(output, files, libs, include_path, library_path):
  """Entry point of the linker."""

  objects = set()
  modules = {}
  for file in files:
    ext = os.path.splitext(file)[1]

    # Object files.
    if ext == '.o':
      objects.add(file)
      with open(file, 'r') as f:
        data = f.read()
        modules[file] = parse_object(data)
      continue

    # Archives containing object files.
    if ext == '.a':
      with open(file, 'r') as f:
        lines = f.readlines()
        assert lines[0].strip() == 'GenM'
        for line in lines[1:]:
          name, data = line.split(': ')
          ident = file + '/' + name
          data = base64.b64decode(bytearray(data, 'UTF-8'))
          m = parse_object(data)
          modules[ident] = m
          if 'main' in m.defs:
            objects.add(ident)

  defined_in = {}
  all_globls = set()
  for file, m in modules.iteritems():
    all_globls |= m.globl
    for d in m.defs:
      defined_in[d] = file

  graph = defaultdict(set)
  for file, m in modules.iteritems():
    for n in m.needs:
      if n not in defined_in:
        all_globls.add(n)
        continue
      source = defined_in[n]
      graph[file].add(source)

  def traverse(obj):
    for src in list(graph[obj]):
      if src in objects:
        continue
      objects.add(src)
      traverse(src)

  for obj in list(objects):
    traverse(obj)

  def emit_segment(seg):
    all_defs = set()
    all_needs = set()
    o.write('\t.%s\n' % seg)
    for n, obj in zip(range(len(objects)), objects):
      m = modules[obj]
      emit_object(seg, o, n, m, all_defs, all_globls)
      all_defs |= m.defs
      all_needs |= m.needs

  with open(output, 'w') as o:
    all_defs = set()
    all_needs = set()
    for obj in objects:
      m = modules[obj]
      all_defs |= m.defs
      all_needs |= m.needs
    for ext in sorted(all_needs - all_defs):
      o.write('\t.extern %s\n' % ext)

    emit_segment('text')
    emit_segment('data')
    emit_segment('bss')
    emit_segment('const')

if __name__ == '__main__':
  # Parse arguments for the linker..
  parser = argparse.ArgumentParser(description='GenM linker (Text)')
  parser.add_argument('files', nargs='+')
  parser.add_argument(
      '-I',
      help='Include search path',
      action='append'
  )
  parser.add_argument(
      '-L',
      help='Library search path',
      action='append'
  )
  parser.add_argument(
      '-l',
      help='Library to link with',
      action='append'
  )
  parser.add_argument(
      '-o',
      help='Output file'
  )
  args = parser.parse_args()

  # Run the GenM text linker.
  main(args.o, args.files, args.l, args.I, args.L)
