#!/usr/bin/env python

from collections import defaultdict
import argparse
import os
import sys
import base64



################################################################################
# Operands to instructions and directives
################################################################################
class Register(object):
  def __init__(self, reg):
    self.reg = reg

  def str(self):
    return self.reg

  def rename(self, sym):
    pass

class Immediate(object):
  def __init__(self, imm):
    self.imm = imm

  def str(self):
    return self.imm

  def rename(self, sym):
    pass

class Symbol(object):
  def __init__(self, label, imm):
    self.label = label
    self.imm = imm

  def str(self):
    if self.imm < 0:
      return '%s-%d' % (self.label, -self.imm)
    if self.imm > 0:
      return '%s+%d' % (self.label, +self.imm)
    return self.label

  def rename(self, sym):
    self.label = sym(self.label)

class String(object):
  def __init__(self, value):
    self.value = value

  def str(self):
    return self.value

  def rename(self, sym):
    pass



################################################################################
# Instructions which are part of atoms
################################################################################
class Directive(object):
  def __init__(self, op, args):
    self.op = op
    self.args = args

  def str(self):
    return '  %s %s' % (
        self.op.ljust(12),
        ', '.join(x.str() for x in self.args)
    )

  def rename(self, sym):
    for arg in self.args:
      arg.rename(sym)

class Instruction(object):
  def __init__(self, op, args, annot):
    self.op = op
    self.args = args
    self.annot = annot

  def str(self):
    return '  %s %s%s' % (
        self.op.ljust(16),
        ', '.join(x.str() for x in self.args),
        '' if not self.annot else ' ' + ' '.join('@' + a for a in self.annot)
    )

  def rename(self, sym):
    for arg in self.args:
      arg.rename(sym)

class Label(object):
  def __init__(self, label):
    self.label = label
    self.is_weak = False
    self.is_global = False

  def str(self):
    return self.label + ':'

  def rename(self, sym):
    self.label = sym(self.label)



################################################################################
# A module, corresponding to an object file.
################################################################################
class Module(object):
  def __init__(self, data):
    self._insts = []
    self.parsed = False

    self.seg_text = []
    self.seg_data = []
    self.seg_const = []
    self.seg_bss = []

    self._weaks = set()
    self._globl = set()
    self._defs = set()
    self._needs = set()

    for line in data.split('\n'):
      line = line.replace('\t', ' ').strip()
      if not line: continue

      if line.startswith('.globl'):
        self._globl.add([t for t in line.split(' ') if t][1])
        continue
      if line.startswith('.weak'):
        self._weaks.add([t for t in line.split(' ') if t][1])
        continue
      if line.startswith('.comm'):
        args = ' '.join(line.split(' ')[1:]).split('#')[0].strip().split(',')
        name, size, align = args

        self._weaks.add(name)

        self._insts.append('.data')
        self._insts.append(name + ':')
        self._insts.append('.align ' + str(align))
        self._insts.append('.space ' + str(size))
        continue

      self._insts.append(line)

    self._globl = self._globl | self._weaks

  def has_weak(self, sym):
    return sym in self._weaks

  def get_globl(self):
    return self._globl

  def get_defs(self):
    self._parse()
    return self._defs

  def get_needs(self):
    self._parse()
    return self._needs

  def _parse(self):
    """Parses a file, extracting instructions."""

    if self.parsed: return
    self.parsed = True

    def parsed_insts():
      """Helper generator to parse the stream into instructions."""
      for line in self._insts:
        # Find an empty line.
        if '"' not in line:
          line = line.split('#')[0].strip('\t ').replace('\t', ' ')
        if not line: continue

        # Split off annotations.
        annots = line.split(' @')
        line = annots[0]
        annots = annots[1:]

        # Split off arguments.
        cmd = line.split(' ')[0].split('\t')[0]
        if cmd == '.ascii' or cmd == '.asciz':
          args = [line[len(cmd):]]
        else:
          args = [x for x in (t.strip('\t ') for t in line[len(cmd):].split(',')) if x]

        # Rewrite some commands.
        if cmd == '.section' and args[0] == '".note.GNU-stack"':
          continue
        if cmd == '.section' and args[0] == '__TEXT':
          cmd = '.text'
          args = []
        if cmd == '.section' and args[0].startswith('.rodata'):
          cmd = '.const'
          args = []

        def parse(arg):
          if arg.startswith('$') or arg.startswith('['):
            return Register(arg)
          if '"' in arg:
            return String(arg)
          if '+' in arg and not arg.startswith('+'):
            tokens = arg.split('+')
            return Symbol(tokens[0].split('@')[0], +int(tokens[1]))
          if '-' in arg and not arg.startswith('-'):
            tokens = arg.split('-')
            return Symbol(tokens[0].split('@')[0], -int(tokens[1]))
          if arg.startswith('0x') or arg.startswith('-') or arg.isdigit():
            return Immediate(arg)
          return Symbol(arg.split('@')[0], 0)

        if cmd not in ['.call', '.args']:
          args = [parse(arg) for arg in args]
        else:
          args = [Immediate(arg) for arg in args]

        if cmd.endswith(':'):
          # Label
          yield Label(cmd[:-1])
        elif not cmd.startswith('.'):
          # Instruction
          yield Instruction(cmd, args, annots)
        else:
          # Directive
          if cmd in ['.file', '.ident']:
            continue
          if cmd == '.asciz':
            yield Directive('.ascii', [args[0]])
            yield Directive('.space', [Immediate("1")])
          elif cmd == '.p2align':
            yield Directive('.align', [Immediate(str(2**int(args[0].imm)))])
          else:
            yield Directive(cmd, args)

    seg = self.seg_text

    needs = set()
    defs = set()

    for i in parsed_insts():
      """Split the stream into segments."""
      if isinstance(i, Label):
        defs.add(i.label)
        seg.append(i)
        continue

      if isinstance(i, Directive):
        if i.op == '.text':  seg = self.seg_text;  continue
        if i.op == '.data':  seg = self.seg_data;  continue
        if i.op == '.bss':   seg = self.seg_bss;   continue
        if i.op == '.const': seg = self.seg_const; continue

      for arg in i.args:
        if isinstance(arg, Symbol):
          needs.add(arg.label)

      seg.append(i)

    self._needs = needs - defs
    self._defs = defs & self._globl
    self._insts = []


def emit_segment(seg, o, insts):
  """Emits a segment of an object."""

  o.write('\t.%s\n' % seg)
  for inst in insts:
    o.write(inst.str())
    o.write('\n')
  o.flush()


def link_segment(m, n, target, src, defs, rename):
  """Links a module into the segment."""

  skip = False
  for inst in src:
    if isinstance(inst, Label):
      skip = m.has_weak(inst.label) and inst.label in defs
    if not skip:
      inst.rename(rename)
      target.append(inst)


def main(output, files, libs, include_path, library_path):
  """Entry point of the linker."""

  objects = set()
  modules = {}
  for file in files:
    ext = os.path.splitext(file)[1]

    # Object files.
    if ext == '.o':
      with open(file, 'r') as f:
        data = f.read()
        modules[file] = Module(data)
      continue

    # Archives containing object files.
    if ext == '.a':
      with open(file, 'r') as f:
        lines = f.readlines()
        assert lines[0].strip() == 'GenM'
        for line in lines[1:]:
          name, data = line.split(': ')
          ident = file + '/' + name
          data = base64.b64decode(bytearray(data, 'UTF-8'))
          m = Module(data)
          modules[ident] = m

  defined_in = {}
  all_globls = set()
  externs = set()
  for file, m in modules.iteritems():
    if 'main' in m.get_globl():
      objects.add(file)
    all_globls |= m.get_globl()
    for d in m.get_globl():
      defined_in[d] = file

  # Select the transitive dependencies of the main object.
  def traverse(obj):
    for n in list(modules[obj].get_needs()):
      if n not in defined_in:
        externs.add(n)
        continue
      src = defined_in[n]
      if src in objects:
        continue
      objects.add(src)
      traverse(src)

  for obj in list(objects):
    traverse(obj)

  # Link the segments together.
  seg_text = []
  seg_data = []
  seg_bss = []
  seg_const = []

  def rename(sym):
    if sym in all_globls or sym in externs:
      return sym
    return '%s.%d' % (sym, n)

  all_defs = set()
  for n, obj in zip(range(len(objects)), objects):
    m = modules[obj]
    link_segment(m, n, seg_text,  m.seg_text,  all_defs, rename)
    link_segment(m, n, seg_data,  m.seg_data,  all_defs, rename)
    link_segment(m, n, seg_bss,   m.seg_bss,   all_defs, rename)
    link_segment(m, n, seg_const, m.seg_const, all_defs, rename)
    all_defs |= m.get_defs()


  # Output the linked segments.
  with open(output, 'w') as o:
    for ext in sorted(externs):
      o.write('\t.extern %s\n' % ext)

    emit_segment('text',  o, seg_text)
    emit_segment('data',  o, seg_data)
    emit_segment('bss',   o, seg_bss)
    emit_segment('const', o, seg_const)


if __name__ == '__main__':
  # Parse arguments for the linker..
  parser = argparse.ArgumentParser(description='GenM linker (Text)')
  parser.add_argument('files', nargs='+')
  parser.add_argument(
      '-I',
      help='Include search path',
      action='append'
  )
  parser.add_argument(
      '-L',
      help='Library search path',
      action='append'
  )
  parser.add_argument(
      '-l',
      help='Library to link with',
      action='append'
  )
  parser.add_argument(
      '-o',
      help='Output file'
  )
  parser.add_argument('-O1', help='Optimisation level')
  parser.add_argument('-O2', help='Optimisation level')
  parser.add_argument('-O3', help='Optimisation level')
  args = parser.parse_args()

  # Run the GenM text linker.
  main(args.o, args.files, args.l, args.I, args.L)
